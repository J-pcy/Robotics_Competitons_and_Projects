#include <hidef.h>      /* common defines and macros */
#include "derivative.h"      /* derivative-specific definitions */
#include "Delay.h"
#include "Lcd.h"


//汉字编码表,用LCD3310.exe软件可以获取汉字编码
typedef struct typHZ_GB12	/*12*12 汉字字模显示数据结构,一个汉字分为上下两层*/
{
   char Index[2];//一个汉字占两个字节
   char Msk[24];//一个汉字的编码由24个十六进制数组成
};

struct typHZ_GB12 const  GB_12[] ={ 
{"距",{0xEF,0x09,0xF9,0x4F,0x40,0xFF,0x49,0x49,0x49,0x79,0x01,0x00,0x07,0x04,0x03,0x02,0x02,0x07,0x04,0x04,0x04,0x04,0x04,0x00}},
{"离",{0x02,0x82,0xBE,0xA2,0xB6,0xEB,0xB6,0xA2,0xBE,0x82,0x02,0x00,0x00,0x07,0x00,0x02,0x03,0x02,0x02,0x03,0x04,0x07,0x00,0x00}},
{"温",{0x89,0x72,0x00,0xC0,0x5F,0xD5,0x55,0xD5,0x55,0xDF,0x00,0x00,0x07,0x00,0x04,0x07,0x04,0x07,0x04,0x07,0x04,0x07,0x04,0x00}},
{"度",{0x00,0xFE,0x0A,0x8A,0xBE,0xAA,0xAB,0xAA,0xBE,0x0A,0x0A,0x00,0x06,0x01,0x04,0x04,0x04,0x03,0x02,0x03,0x04,0x04,0x04,0x00}},
{"角",{0x10,0x08,0xFC,0xAB,0xAA,0xFA,0xAE,0xAA,0xA8,0xF8,0x00,0x00,0x04,0x02,0x01,0x00,0x00,0x07,0x00,0x04,0x04,0x07,0x00,0x00}},
{"度",{0x00,0xFE,0x0A,0x8A,0xBE,0xAA,0xAB,0xAA,0xBE,0x0A,0x0A,0x00,0x06,0x01,0x04,0x04,0x04,0x03,0x02,0x03,0x04,0x04,0x04,0x00}}
//{"",{}},
};


//ASCII码编码表
 uchar font6x8[][6] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp      00
    { 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00 },   // !       01
    { 0x00, 0x00, 0x07, 0x00, 0x07, 0x00 },   // "       02
    { 0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14 },   // #       03
    { 0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12 },   // $       04
    { 0x00, 0x62, 0x64, 0x08, 0x13, 0x23 },   // %       05
    { 0x00, 0x36, 0x49, 0x55, 0x22, 0x50 },   // &       06
    { 0x00, 0x00, 0x05, 0x03, 0x00, 0x00 },   // '       07
    { 0x00, 0x00, 0x1c, 0x22, 0x41, 0x00 },   // (       08
    { 0x00, 0x00, 0x41, 0x22, 0x1c, 0x00 },   // )       09
    { 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14 },   // *       10
    { 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08 },   // +       11
    { 0x00, 0x00, 0x00, 0xA0, 0x60, 0x00 },   // ,       12
    { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08 },   // -       13
    { 0x00, 0x00, 0x60, 0x60, 0x00, 0x00 },   // .       14
    { 0x00, 0x20, 0x10, 0x08, 0x04, 0x02 },   // /       15
    { 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E },   // 0       16
    { 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00 },   // 1       17
    { 0x00, 0x42, 0x61, 0x51, 0x49, 0x46 },   // 2       18
    { 0x00, 0x21, 0x41, 0x45, 0x4B, 0x31 },   // 3       19
    { 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10 },   // 4       20
    { 0x00, 0x27, 0x45, 0x45, 0x45, 0x39 },   // 5       21
    { 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30 },   // 6       22
    { 0x00, 0x01, 0x71, 0x09, 0x05, 0x03 },   // 7       23
    { 0x00, 0x36, 0x49, 0x49, 0x49, 0x36 },   // 8       24
    { 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E },   // 9       25
    { 0x00, 0x00, 0x36, 0x36, 0x00, 0x00 },   // :       26
    { 0x00, 0x00, 0x56, 0x36, 0x00, 0x00 },   // ;       27
    { 0x00, 0x08, 0x14, 0x22, 0x41, 0x00 },   // <       28
    { 0x00, 0x14, 0x14, 0x14, 0x14, 0x14 },   // =       29
    { 0x00, 0x00, 0x41, 0x22, 0x14, 0x08 },   // >       30
    { 0x00, 0x02, 0x01, 0x51, 0x09, 0x06 },   // ?       31
    { 0x00, 0x32, 0x49, 0x59, 0x51, 0x3E },   // @       32
    { 0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C },   // A       33
    { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36 },   // B       34
    { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22 },   // C       35
    { 0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C },   // D       36
    { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41 },   // E       37
    { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01 },   // F       38
    { 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A },   // G       39
    { 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F },   // H       40
    { 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00 },   // I       41
    { 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01 },   // J       42
    { 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41 },   // K       43
    { 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40 },   // L       44
    { 0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F },   // M       45
    { 0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F },   // N       46
    { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E },   // O       47
    { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06 },   // P       48
    { 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E },   // Q       49
    { 0x00, 0x7F, 0x09, 0x19, 0x29, 0x46 },   // R       50
    { 0x00, 0x46, 0x49, 0x49, 0x49, 0x31 },   // S       51
    { 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01 },   // T       52
    { 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F },   // U       53
    { 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F },   // V       54
    { 0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F },   // W       55
    { 0x00, 0x63, 0x14, 0x08, 0x14, 0x63 },   // X       56
    { 0x00, 0x07, 0x08, 0x70, 0x08, 0x07 },   // Y       57
    { 0x00, 0x61, 0x51, 0x49, 0x45, 0x43 },   // Z       58
    { 0x00, 0x00, 0x7F, 0x41, 0x41, 0x00 },   // [       59
    { 0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55 },   // 55      60
    { 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00 },   // ]       61
    { 0x00, 0x04, 0x02, 0x01, 0x02, 0x04 },   // ^       62
    { 0x00, 0x40, 0x40, 0x40, 0x40, 0x40 },   // _       63
    { 0x00, 0x00, 0x01, 0x02, 0x04, 0x00 },   // '       64
    { 0x00, 0x20, 0x54, 0x54, 0x54, 0x78 },   // a       65
    { 0x00, 0x7F, 0x48, 0x44, 0x44, 0x38 },   // b       66
    { 0x00, 0x38, 0x44, 0x44, 0x44, 0x20 },   // c       67
    { 0x00, 0x38, 0x44, 0x44, 0x48, 0x7F },   // d       68
    { 0x00, 0x38, 0x54, 0x54, 0x54, 0x18 },   // e       69
    { 0x00, 0x08, 0x7E, 0x09, 0x01, 0x02 },   // f       70
    { 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C },   // g       71
    { 0x00, 0x7F, 0x08, 0x04, 0x04, 0x78 },   // h       72
    { 0x00, 0x00, 0x44, 0x7D, 0x40, 0x00 },   // i       73
    { 0x00, 0x40, 0x80, 0x84, 0x7D, 0x00 },   // j       74
    { 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00 },   // k       75
    { 0x00, 0x00, 0x41, 0x7F, 0x40, 0x00 },   // l       76
    { 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78 },   // m       77
    { 0x00, 0x7C, 0x08, 0x04, 0x04, 0x78 },   // n       78
    { 0x00, 0x38, 0x44, 0x44, 0x44, 0x38 },   // o       79
    { 0x00, 0xFC, 0x24, 0x24, 0x24, 0x18 },   // p       80
    { 0x00, 0x18, 0x24, 0x24, 0x18, 0xFC },   // q       81
    { 0x00, 0x7C, 0x08, 0x04, 0x04, 0x08 },   // r       82
    { 0x00, 0x48, 0x54, 0x54, 0x54, 0x20 },   // s       83
    { 0x00, 0x04, 0x3F, 0x44, 0x40, 0x20 },   // t       84
    { 0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C },   // u       85
    { 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C },   // v       86
    { 0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C },   // w       87
    { 0x00, 0x44, 0x28, 0x10, 0x28, 0x44 },   // x       88
    { 0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C },   // y       89
    { 0x00, 0x44, 0x64, 0x54, 0x4C, 0x44 },   // z       90
    { 0x14, 0x14, 0x14, 0x14, 0x14, 0x14 }    // horiz lines
};


/**********************************************************************
* 函数名称：LCD_init()		
* 函数功能：初始化nokia5110
* 入口参数：无
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_Init(void)
  {           
    LCD_RST = 0; // 产生一个让LCD复位的低电平脉冲
    Delay_us(1);
    LCD_RST = 1;
    LCD_CE = 0;// 关闭LCD  
    Delay_us(1);		
    LCD_CE = 1;// 使能LCD
    Delay_us(1);
    LCD_write_byte(0x21, 0);	// 使用扩展命令设置LCD模式
    LCD_write_byte(0xc8, 0);	// 设置偏置电压
    LCD_write_byte(0x06, 0);	// 温度校正
    LCD_write_byte(0x13, 0);	// 1:48
    LCD_write_byte(0x20, 0);	// 使用基本命令
    LCD_clear();	            // 清屏
    LCD_write_byte(0x0c, 0);	// 设定显示模式，正常显示        
    LCD_CE = 0;               // 关闭LCD  
  }
  
 /**********************************************************************
* 函数名称：LCD_clear()		
* 函数功能：液晶清屏
* 入口参数：无
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_clear(void)
  {
    uint i;
    LCD_write_byte(0x0c, 0);			
    LCD_write_byte(0x80, 0);	
    for (i=0; i<504; i++)
      LCD_write_byte(0, 1);			
  }
  
/**********************************************************************
* 函数名称：LCD_write_byte()
* 函数功能：写一个字节
* 入口参数：data,要写入的字节;command:0为命令,1为数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_write_byte(uchar data, uchar command)
{
  uchar i;    
  LCD_CE = 0;    
  if (command == 0)     
   LCD_DC = 0;
  else    
   LCD_DC = 1;
	for(i=0;i<8;i++)
	{
		if(data&0x80)
			SDIN = 1;
		else
			SDIN = 0;
		SCLK = 0;
		data= data<< 1;
		SCLK = 1;
	}   
   LCD_CE = 1;
}

/**********************************************************************
* 函数名称：LCD_set_XY()
* 函数功能：光标定位x行y列
* 入口参数：X,Y   x行y列
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_set_XY(uchar X, uchar Y)
  {
    LCD_write_byte(0x40 | Y, 0);		// column
    LCD_write_byte(0x80 | X, 0);        // row
  }
  
 /***********************************************************************
* 函数名称：LCD_write_char()
* 函数功能：写入1个字符
* 入口参数：c   要写入的数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_write_char(uchar c)
  {
    uchar line;
    c -= 32;
    for (line=0; line<6; line++)
      LCD_write_byte(font6x8[c][line], 1);//从ACSII码表中读取字节，然后写入液晶
  }
  
/***********************************************************************
* 函数名称：LCD_Write_Char()
* 函数功能：写入1个字符
* 入口参数：X:行;Y:列;asc:要写入的数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_Write_Char(uchar X,uchar Y,uchar asc)
{
  uchar line;
  LCD_set_XY(X,Y);//光标定位
 // if((asc>=0)&&(asc<=9))
 //   asc = asc+16;
 // else 
    asc = asc-32;
  for (line=0; line<6; line++)
    LCD_write_byte(font6x8[asc][line], 1);//从ACSII码表中读取字节，然后写入液晶
}

/***********************************************************************
* 函数名称：LCD_Write_Num()
* 函数功能：显示变亮
* 入口参数：X:行;Y:列;num:变量;N:要显示的变量的位数
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_Write_Num(uchar X,uchar Y,uint num,uchar N)
{
  uchar line;
  uchar i=0;
  uint n[5]={0};
  n[0]= num%10;
  n[1]=(num/10)%10;
  n[2]=(num/100)%10;
  n[3]=(num/1000)%10;
  n[4]=(num/10000)%10;
  for(i=0;i<5;i++) n[i]=n[i]+16;
  for(i=N;i>0;i--) 
  {
    LCD_set_XY(X+(N-i)*6,Y);//光标定位
    for (line=0; line<6; line++)
      LCD_write_byte(font6x8[n[i-1]][line], 1);//从ACSII码表中读取字节，然后写入液晶
  }
}


/***********************************************************************
* 函数名称LLCD_write_english_string()
* 函数功能：写英文字符串
* 入口参数：X,Y,*S------x行y列*s为英文字符串
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_write_english_string(uchar X,uchar Y,char *s)
  {
    LCD_set_XY(X,Y);//光标定位
    while (*s) 
    {
  	 LCD_write_char(*s);
  	 s++;
    }
  }


/***********************************************************************
* 函数名称： LCD_Write_String()
* 函数功能：写字符串(中英文)
* 入口参数：x,横坐标;y,纵坐标;String,要显示的字符串
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_Write_String(uchar x, uchar y,char *string)
{
  uchar i=0,j=0,k=0,xh=0,yh=0;
  uchar kk,ii;
  char *cc,hz[2]={0}; 
  xh=x,yh=y;
  while(string[i])
  {
     for(kk=0;kk<sizeof(GB_12)/sizeof(GB_12[0]);kk++)//查找汉字编码表中的汉字
     {
      if((string[i]==GB_12[kk].Index[0])&&(string[i+1]==GB_12[kk].Index[1]))
       {
          LCD_set_XY(xh+i*6,yh); //光标定位
          for(ii=0;ii<12;ii++)//先写上半字节
          LCD_write_byte(GB_12[kk].Msk[ii],1);
          LCD_set_XY(xh+i*6,yh+1);//光标定位下一行
          for(ii=12;ii<24;ii++)//后写下半字节
          LCD_write_byte(GB_12[kk].Msk[ii],1);
          i=i+2;
       }
      else if((string[i]>=32)&&(string[i]<=121)) 
       {
          cc=&string[i];
          LCD_set_XY(x+i*6,y);
          LCD_write_char(*cc);
          i=i+1;
       }        
     }    
  }    
}
